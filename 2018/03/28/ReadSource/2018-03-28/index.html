<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
    <meta name="referrer" content="origin">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <title>Swift - 3 [Print.swift]</title>

    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/font/LongCang.css">
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/font/Monda.css">
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/font/NotoSansSC.css">
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/font/Playball.css">
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/font/PTMono.css">
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/font/RobotoSlab.css">
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/font/Rosario.css">
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/font/UbuntuMono.css">

    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/css/post.css">
    
        <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/css/normal.css">
    

    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/js/jquery-3.4.1.min.js"></script>

<meta name="generator" content="Hexo 5.2.0"></head>
<body>
    <a id="cover"></a>
    <div id="header">
    <div class="header">
        <div class="vertical">
            <div class="inner">
                <h1 class="header-subtitle">Swift - 3 [Print.swift]</h1>
                <div class="header-subinfo">
                    <p class="article-info-text">
                        <span>
                            <i class="iconfont icon-time"></i> 发表时间：2018-03-28
                        </span>
                        
                            <span id="/2018/03/28/ReadSource/2018-03-28/" class="leancloud_visitors" data-flag-title="Swift - 3 [Print.swift]">
                                <i class="iconfont icon-browse"></i> 阅读：<sapn class="leancloud-visitors-count"></span>
                            </span>
                        
                        <span>
                            <i class="iconfont icon-interactive"></i> 评论：<span class="valine-comment-count" data-xid="/2018/03/28/ReadSource/2018-03-28/"></span>
                        </span>  
                    </p>                 
                </div>
            </div>
        </div>
        <canvas id="articleHeaderCanvas"></canvas>
    </div>
</div>
    <div id="container">
    <div id="content">
        <div id="article">
    <div class="toc"></div>
    <div class="article-body">
        <p>这是Swift源码 系列第三篇，我们常用的Print函数的源码</p>
<p>####<font color=10a3ee>定义</font><br>Swift 对Print.的定义<br>核心函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@inline(never)</span><br><span class="line">public func print(</span><br><span class="line">  _ items: Any...,</span><br><span class="line">  separator: String &#x3D; &quot; &quot;,</span><br><span class="line">  terminator: String &#x3D; &quot;\n&quot;</span><br><span class="line">) &#123;</span><br><span class="line">  if let hook &#x3D; _playgroundPrintHook &#123;</span><br><span class="line">    var output &#x3D; _TeeStream(left: &quot;&quot;, right: _Stdout())</span><br><span class="line">    _print(</span><br><span class="line">      items, separator: separator, terminator: terminator, to: &amp;output)</span><br><span class="line">    hook(output.left)</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    var output &#x3D; _Stdout()</span><br><span class="line">    _print(</span><br><span class="line">      items, separator: separator, terminator: terminator, to: &amp;output)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@inline(never) 说明了这个函数 never 编译成 inline 的形式，@inline(__always) 则刚好相反。<br>separator 和 terminator 两个参数，按照注释就是分割符和终止符<br>注释示意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">separator: A string to print between each item. The default is a single space (&#96;&quot; &quot;&#96;).</span><br><span class="line">terminator: The string to print after all items have been printed. The default is a newline (&#96;&quot;\n&quot;&#96;).</span><br></pre></td></tr></table></figure>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;swift 4.x&quot;, terminator: &quot;---&quot;)</span><br><span class="line">print(&quot;Hello&quot;, &quot;Swift&quot;, 2, separator:&quot;??&quot;)</span><br><span class="line">print(&quot;Hello&quot;, &quot;Swift&quot;, 2, separator:&quot;   &quot;, terminator:&quot;.&quot;)</span><br></pre></td></tr></table></figure>
<p>打印如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swift 4.x---Hello??Swift??2 </span><br><span class="line">Hello   Swift   2.</span><br></pre></td></tr></table></figure>
<p>默认的分隔符和终止符都可以替代<br>接下来</p>
<p><code>if let hook = _playgroundPrintHook&#123;&#125;</code></p>
<p>这句应该是判断是否playground，然后再设置相应的output，这里是用_TeeStream<br>来output，而如果不是playground，其他则是_Stdout。</p>
<p>_TeeStream</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">internal struct _TeeStream&lt;</span><br><span class="line">  L : TextOutputStream,</span><br><span class="line">  R : TextOutputStream</span><br><span class="line">&gt; : TextOutputStream</span><br></pre></td></tr></table></figure>
<p>TextOutputStream是标准库内置的一个标准输出流协议，</p>
<p><code>_TeeStream(left: &quot;&quot;, right: _Stdout())</code></p>
<p>实际上还是调用标准输出流协议_Stdout()，TextOutputStream注释如下</p>
<p><img src="./s1.png"></p>
<p>_print</p>
<p>从上面print方法最后实质上还是调用_print函数，对外则提供了一个重载的，高度可定制的print函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">internal func _print&lt;Target : TextOutputStream&gt;(</span><br><span class="line">  _ items: [Any],</span><br><span class="line">  separator: String &#x3D; &quot; &quot;,</span><br><span class="line">  terminator: String &#x3D; &quot;\n&quot;,</span><br><span class="line">  to output: inout Target</span><br><span class="line">) &#123;</span><br><span class="line">  var prefix &#x3D; &quot;&quot;</span><br><span class="line">  output._lock()</span><br><span class="line">  defer &#123; output._unlock() &#125;</span><br><span class="line">  for item in items &#123;</span><br><span class="line">    output.write(prefix)</span><br><span class="line">    _print_unlocked(item, &amp;output)</span><br><span class="line">    prefix &#x3D; separator</span><br><span class="line">  &#125;</span><br><span class="line">  output.write(terminator)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在正文第3行有个defer关键字，defer 是干什么用的。<br>在作用域方面，defer block 里的代码会在函数 return 之前执行，无论函数是从哪个分支 return 的，还是有 throw，还是自然而然走到最后一行。类似 try-catch-finally 的finally一样。多用于加锁的场景。<br>再次来看这部分核心代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for item in items &#123;</span><br><span class="line">  output.write(prefix)    &#x2F;&#x2F;每两个元素之间用separator来分隔开</span><br><span class="line">  _print_unlocked(item, &amp;output)  &#x2F;&#x2F; 核心函数</span><br><span class="line">  prefix &#x3D; separator </span><br><span class="line">&#125;</span><br><span class="line">output.write(terminator)      &#x2F;&#x2F; 终止符，通常默认是&quot;\n&quot;</span><br></pre></td></tr></table></figure>
<p>到现在来看在此函数里面，只有_ items: [Any],  to output: inout Target 两个参数最为关键，也就是说只需要关心输入参数和输出到哪里，输出格式则是次要的。以上代码可以看的出来<em>print是用来处理输出格式的，并将</em> items: [Any]里的元素写入到output中。<br>示例:</p>
<p><code>print(&quot;Hello,world!&quot;)</code></p>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var output &#x3D; _Stdout()    &#x2F;&#x2F; 这个是output的默认值</span><br><span class="line">output.write(&quot;&quot;)    &#x2F;&#x2F; prefix是一个空字符串</span><br><span class="line">_print_unlocked(&quot;Hello, world!&quot;, &amp;output)</span><br></pre></td></tr></table></figure>
<p>那么这个output到底是什么？<br>####<font color=10a3ee>_Stdout</font><br>前面说var output = _Stdout() ，_Stdout的定义和方法简化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">internal struct _Stdout : TextOutputStream &#123;</span><br><span class="line">  internal init() &#123;&#125;</span><br><span class="line">  internal mutating func _lock() &#123;</span><br><span class="line">    _swift_stdlib_flockfile_stdout()</span><br><span class="line">  &#125;</span><br><span class="line">  internal mutating func _unlock() &#123;</span><br><span class="line">    _swift_stdlib_funlockfile_stdout()</span><br><span class="line">  &#125;</span><br><span class="line">  internal mutating func write(_ string: String) &#123;</span><br><span class="line">    if string.isEmpty &#123; return &#125;</span><br><span class="line">    if let asciiBuffer &#x3D; string._core.asciiBuffer &#123;</span><br><span class="line">      defer &#123; _fixLifetime(string) &#125;</span><br><span class="line">      _stdlib_fwrite_stdout(</span><br><span class="line">        UnsafePointer(asciiBuffer.baseAddress!),</span><br><span class="line">        asciiBuffer.count,</span><br><span class="line">        1)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    for c in string.utf8 &#123;</span><br><span class="line">      _stdlib_putchar_unlocked(Int32(c))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先_Stdout继承了TextOutputStream协议，重写了write方法，<br>在write方法里，</p>
<p><code>if string.isEmpty &#123; return &#125;</code></p>
<p>判读输出为空，则提前返回；然后 </p>
<p><code>if let asciiBuffer = string._core.asciiBuffer &#123; &#125;</code></p>
<p>是先判断是否是ascii码，_stdlib_fwrite_stdout（定义在LibcShims.cpp文件中），函数传入的分别是UnsafePointer(asciiBuffer.baseAddress!)：函数指针、asciiBuffer.count：空间大小、1：ascii码的数量，由此看来对ascii码单独进行了处理。<br>接下来 for循环，_Stdout是在字符串的UTF-8编码视图下，把每个字符转换成Int32类型，然后调用_stdlib_putchar_unlocked函数（也定义在LibcShims.cpp文件中），到最后是调用c定义的宏 __sputc。（本系列是不分析c 语言方法的具体实现的（其实我也不懂。。😆））<br>最后还有句</p>
<p><code>defer &#123; _fixLifetime(string) &#125;</code></p>
<p> 意思是修复输出流在堆上的生命周期。<br>所以_Stdout是继承TextOutputStream协议的输出流。</p>
<p>####<font color=10a3ee>_print_unlocked</font><br>我们知道了_Stdout只是个输出流，实际上_print是通过_print_unlocked来输出内容的，它的定义如下(方法位于OutputSteam.swift文件中)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@_versioned</span><br><span class="line">@inline(never)</span><br><span class="line">@_semantics(&quot;optimize.sil.specialize.generic.never&quot;) &#x2F;&#x2F; 不进行sil语义优化</span><br><span class="line">internal func _print_unlocked&lt;T, TargetStream : TextOutputStream&gt;(</span><br><span class="line">  _ value: T, _ target: inout TargetStream</span><br><span class="line">) &#123;</span><br><span class="line">  if _isOptional(type(of: value)) &#123;</span><br><span class="line">    let debugPrintable &#x3D; value as! CustomDebugStringConvertible</span><br><span class="line">    debugPrintable.debugDescription.write(to: &amp;target)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  if case let TextOutputStreamObject as TextOutputTextOutputStream &#x3D; value &#123;</span><br><span class="line">    TextOutputStreamObject.write(to: &amp;target)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  if case let printableObject as CustomStringConvertible &#x3D; value &#123;</span><br><span class="line">    printableObject.description.write(to: &amp;target)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  if case let debugPrintableObject as CustomDebugStringConvertible &#x3D; value &#123;</span><br><span class="line">    debugPrintableObject.debugDescription.write(to: &amp;target)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  let mirror &#x3D; Mirror(reflecting: value)</span><br><span class="line">  _adHocPrint_unlocked(value, mirror, &amp;target, isDebugPrint: false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中有四个判断，三个关键协议判断，分别判断输出的value是否实现了指定的TextOutputTextOutputStream、CustomStringConvertible、CustomDebugStringConvertible协议，如果是，则调用该协议下writeTo方法并提前返回，而最后的_adHocPrint_unlocked是用于确保任何类型都有默认输出。<br>来看TextOutputTextOutputStream协议，就是上面已经说过的_TeeStream参数协议了，它的定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public protocol TextOutputTextOutputStream &#123;</span><br><span class="line">  func write&lt;Target : TextOutputStream&gt;(to target: inout Target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TextOutputTextOutputStream协议</p>
<p><img src="./QQ20180329-152154.png"></p>
<p>查看三个协议，可以看出来，如果是TextOutputTextOutputStream协议就打印出来它的值；如果实现的是CustomStringConvertible、CustomDebugStringConvertible协议，print实际打印的是description内容。<br>也就是说如果是可空和字符类型，直接打印，不是则继续走。<br>####<font color=10a3ee>复杂类型</font><br>其他类型调用下面方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  let mirror &#x3D; Mirror(reflecting: value)</span><br><span class="line">_adHocPrint_unlocked(value, mirror, &amp;target, isDebugPrint: false)</span><br></pre></td></tr></table></figure>

<p>Mirror 注释如下：</p>
<p><img src="./QQ20180329-152950.png"><br>也就是说是个提供显示的渲染结构（这里就不细说了）。<br>各种类型的打印方法在_adHocPrint_unlocked（在OutputStream.Swift文件里）方法里，（代码在下面），主要就是一些类型判断和打印。<br>####<font color=10a3ee>总结</font><br>上面说_Stdout有个write方法可以打印，为什么还要调用_print_unlocked函数？先看下String关于协议的扩展：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension String : TextOutputTextOutputStream &#123;</span><br><span class="line">  public func write&lt;Target : TextOutputStream&gt;(to target: inout Target) &#123;</span><br><span class="line">    target.write(self)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_print_unlocked函数里面方法都是调用的write(to:)方法，实际上就是TextOutputTextOutputStream协议的方法，用于输出内容到屏幕上，_Stdout的write函数实际上会调用C语言的_stdlib_putchar_unlocked函数,但是字符串的write(to:)还是调用write方法（见extension String : TextOutputTextOutputStream）<br>实际上也就是<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内容.writeTo(输出流) &#x3D; 输出流.write(内容)，一般在前者内部执行后者</span><br></pre></td></tr></table></figure><br>字符串不仅是TextOutputTextOutputStream类型还是TextOutputStream</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension String : TextOutputStream &#123;</span><br><span class="line">  public mutating func write(_ other: String) &#123;</span><br><span class="line">    self +&#x3D; other</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在print方法是一般作为可输出特性。<br>另：<br>debugPrint在发布的版本里也 会输出。<br>debugPrint只是更倾向于输出对象的调试信息。不管是开发环境还是测试环境都会输出的。</p>
<p>####<font color=10a3ee>实践</font><br>一、字符串输出<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;Hello, world!&quot;)</span><br></pre></td></tr></table></figure>
<p>调用不带output参数的print函数，函数内部生成_Stdout类型的输出流，调用_print函数<br>在_print函数中国处理完separator和terminator等格式参数后，调用_print_unlocked函数处理字符串输出。<br>在_print_unlocked函数的第一个if判断中，因为字符串类型实现了TextOutputTextOutputStream协议，所以调用字符串的writeTo函数，写入到输出流中。<br>根据字符串的writeTo函数的定义，它在内部调用了输出流的write方法<br>_Stdout在其write方法中，调用C语言的putchar函数输出字符串的每个字符</p>
<p>二、标准库中其他类型输出</p>
<p>如果要输出一个整数，似乎和输出字符串一样简单，但其实并不是这样，我们来分析一下具体的步骤：</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(123) </span><br></pre></td></tr></table></figure>
<p>调用不带output参数的print函数，函数内部生成_Stdout类型的输出流，调用_print函数<br>在_print函数中国处理完separator和terminator等格式参数后，调用_print_unlocked函数处理字符串输出。<br>截止目前和输出字符串一致，不过Int类型(以及其他除了和字符有关的几乎所有类型)没有实现TextOutputStream协议，它实现的是CustomStringConvertible协议，定义了自己的计算属性description<br>description是一个字符串类型，调用字符串的writeTo方法此前已经讲过，就不再赘述了。</p>
<p>三、自定义结构体输出</p>
<p>我们简单的定义一个结构体，然后尝试使用print方法输出这个结构体：<br> 示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    private var age: Int</span><br><span class="line">    init(name: String, age: Int) &#123;</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let kt &#x3D; Person(name: &quot;kt&quot;, age: 21)</span><br><span class="line">print(kt)    &#x2F;&#x2F; 输出结果：PersonStruct(name: &quot;kt&quot;, age: 21)  </span><br></pre></td></tr></table></figure>

<p>输出结果的可读性非常好，我们来分析一下其中的步骤：</p>
<p>调用不带output参数的print函数，函数内部生成_Stdout类型的输出流，调用_print函数<br>在_print函数中国处理完separator和terminator等格式参数后，调用_print_unlocked函数处理字符串输出。<br>在_print_unlocked中调用_adHocPrint函数<br>switch语句匹配，参数类型是结构体，执行对应case语句中的代码<br>前两步和输出字符串一模一样，不过由于是自定义的结构体，而且没有实现任何协议，所以在第三步骤无法满足任意一个if判断。于是调用_adHocPrint函数，这个函数可以确保任何类型都能在print方法中较好的工作。在_adHocPrint函数中也有switch判断，如果被输出的变量是一个结构体，则会执行对应的操作，<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">internal func _adHocPrint_unlocked&lt;T, TargetStream : TextOutputStream&gt;(</span><br><span class="line">    _ value: T, _ mirror: Mirror, _ target: inout TargetStream,</span><br><span class="line">    isDebugPrint: Bool</span><br><span class="line">) &#123;</span><br><span class="line">  func printTypeName(_ type: Any.Type) &#123;</span><br><span class="line">    target.write(_typeName(type, qualified: isDebugPrint))</span><br><span class="line">  &#125;</span><br><span class="line">  if let displayStyle &#x3D; mirror.displayStyle &#123;</span><br><span class="line">    switch displayStyle &#123;</span><br><span class="line">      case .optional:</span><br><span class="line">        if let child &#x3D; mirror.children.first &#123;</span><br><span class="line">          _debugPrint_unlocked(child.1, &amp;target)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          _debugPrint_unlocked(&quot;nil&quot;, &amp;target)</span><br><span class="line">        &#125;</span><br><span class="line">      case .tuple:</span><br><span class="line">        target.write(&quot;(&quot;)</span><br><span class="line">        var first &#x3D; true</span><br><span class="line">        for (label, value) in mirror.children &#123;</span><br><span class="line">          if first &#123;</span><br><span class="line">            first &#x3D; false</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            target.write(&quot;, &quot;)</span><br><span class="line">          &#125;</span><br><span class="line">          if let label &#x3D; label &#123;</span><br><span class="line">            if !label.isEmpty &amp;&amp; label[label.startIndex] !&#x3D; &quot;.&quot; &#123;</span><br><span class="line">              target.write(label)</span><br><span class="line">              target.write(&quot;: &quot;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          _debugPrint_unlocked(value, &amp;target)</span><br><span class="line">        &#125;</span><br><span class="line">        target.write(&quot;)&quot;)</span><br><span class="line">      case .struct:</span><br><span class="line">        printTypeName(mirror.subjectType)</span><br><span class="line">        target.write(&quot;(&quot;)</span><br><span class="line">        var first &#x3D; true</span><br><span class="line">        for (label, value) in mirror.children &#123;</span><br><span class="line">          if let label &#x3D; label &#123;</span><br><span class="line">            if first &#123;</span><br><span class="line">              first &#x3D; false</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              target.write(&quot;, &quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            target.write(label)</span><br><span class="line">            target.write(&quot;: &quot;)</span><br><span class="line">            _debugPrint_unlocked(value, &amp;target)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        target.write(&quot;)&quot;)</span><br><span class="line">      case .enum:</span><br><span class="line">        if let cString &#x3D; _getEnumCaseName(value),</span><br><span class="line">            let caseName &#x3D; String(validatingUTF8: cString) &#123;</span><br><span class="line">          if isDebugPrint &#123;</span><br><span class="line">            printTypeName(mirror.subjectType)</span><br><span class="line">            target.write(&quot;.&quot;)</span><br><span class="line">          &#125;</span><br><span class="line">          target.write(caseName)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          printTypeName(mirror.subjectType)</span><br><span class="line">        &#125;</span><br><span class="line">        if let (_, value) &#x3D; mirror.children.first &#123;</span><br><span class="line">          if Mirror(reflecting: value).displayStyle &#x3D;&#x3D; .tuple &#123;</span><br><span class="line">            _debugPrint_unlocked(value, &amp;target)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            target.write(&quot;(&quot;)</span><br><span class="line">            _debugPrint_unlocked(value, &amp;target)</span><br><span class="line">            target.write(&quot;)&quot;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      default:</span><br><span class="line">        target.write(_typeName(mirror.subjectType))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if let metatypeValue &#x3D; value as? Any.Type &#123;</span><br><span class="line">    printTypeName(metatypeValue)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if let cString &#x3D; _opaqueSummary(mirror.subjectType),</span><br><span class="line">        let opaqueSummary &#x3D; String(validatingUTF8: cString) &#123;</span><br><span class="line">      target.write(opaqueSummary)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      target.write(_typeName(mirror.subjectType, qualified: true))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以仔细阅读case is Struct这一段。如果此前定义的不是结构体而是类，那么得到的结果只是TextOutputStream.PersonStruct，根据default段中的代码也很容易理解。</p>
<p>正是由于_adHocPrint方法，不仅仅是字符串和Swift内置的类型，任何自定义类型都可以被输出。现在您应该已经明白，为什么输出prefix用的是write方法，而输出字符串”Hello, world!”要用_print_unlocked函数了吧？这是因为在那个时候，编译器还无法判定输出内容的类型。</p>
<p>四、万能的String</p>
<p>不知道您有没有注意到一个细节，String类型的初始化函数是一个没有类型约束的范型函数，也就是说任意类型都可以用来创建一个字符串，这是因为String类型的初始化函数有一个重载为：<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extension String &#123;</span><br><span class="line">  public init&lt;T&gt;(_ instance: T) &#123;</span><br><span class="line">    self.init()</span><br><span class="line">    _print_unlocked(instance, &amp;self)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的字符串不是一个可输出类型，而是作为输出流来使用。_print_unlocked将instance输出到字符串流中。</p>
<p>调试输出<br>在_print_unlocked函数中，我们看到它在输出默认值之前，一共会进行三次判断。依次检验被输出的变量是否实现了TextOutputStream、CustomStringConvertible和CustomDebugStringConvertible，只要实现了协议，就会进行相应的处理并提前退出函数。</p>
<p>这三个协议的优先级依次降低，也就是如果一个类型既实现了TextOutputStream协议又实现了CustomStringConvertible协议，那么将会优先调用TextOutputStream协议中定义的writeTo方法。从这个优先级顺序来看，print函数更倾向于字符串的正常输出而非调试输出。</p>
<p>Swift中还有一个debugPrint函数，它更倾向于输出字符串的调试信息。调用这个函数时，三个协议的优先级完全相反：<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extension PersonDebug: CustomStringConvertible, CustomDebugStringConvertible &#123;</span><br><span class="line">    var description: String &#123;</span><br><span class="line">        return &quot;In CustomStringConvertible Protocol&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    var debugDescription: String &#123;</span><br><span class="line">        return &quot;In CustomDebugStringConvertible Protocol&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let kt &#x3D; PersonDebug(name: &quot;kt&quot;, age: 21)</span><br><span class="line">print(kt)    &#x2F;&#x2F; &quot;In CustomStringConvertible Protocol&quot;</span><br><span class="line">debugPrint(kt)    &#x2F;&#x2F;&quot;In CustomDebugStringConvertible Protocol&quot;</span><br></pre></td></tr></table></figure>
<p>刚刚我们说到，创建字符串时可以传入任意的参数value，最后的字符串的值和调用print(value)的结果完全相同，这是因为两者都会调用_print_unlocked方法。对应到debugPrint函数则有：<br>代码如下:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extension String &#123;</span><br><span class="line">  public init&lt;T&gt;(reflecting subject: T) &#123;</span><br><span class="line">    self.init()</span><br><span class="line">    debugPrint(subject, terminator: &quot;&quot;, toStream: &amp;self)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>简单来说，在_adHocPrint函数之前，这两个输出函数的调用栈是完全平行的关系</p>
<p>参考文档:<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/25951195/swift-print-vs-println-vs-nslog">Swift: print() vs println() vs NSLog()</a><br><a target="_blank" rel="noopener" href="https://oleb.net/blog/2016/09/playground-print-hook/">_playgroundPrintHook</a><br><a target="_blank" rel="noopener" href="https://juejin.im/entry/583fd96f2f301e005cf5568d">Swift - Defer; defer; defer - iO</a><br><a target="_blank" rel="noopener" href="http://www.code4app.com/thread-27302-1-1.html">swift 的 defer 几个简单的使用场景,defer</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/hello_hwc/article/details/46043691">Swift－UnsafePointer, UnsafeMutablePointer，AutoreleasingUnsafeMutablePointer</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/wodemeng/p/5795431.html">UnsafePointer</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/773c46edb735">Swift 源码解读 - Print.swift</a></p>
<!-- [你其实真的不懂print("Hello,world")](https://www.jianshu.com/p/773c46edb735) -->
        <p class="suffix-end">__END__</p>
        <div class="suffix-box">
            <div class="suffix-box-left">
                <img src="https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/image/sidebar/avatar.jpg" alt="林江仙">
            </div>
            <div class="suffix-box-right">
                <span class="suffix-box-title">文章作者</span>：林江仙
                <br>
                <span class="suffix-box-title">文章出处</span>：<a href="/2018/03/28/ReadSource/2018-03-28/" target="_blank">Swift - 3 [Print.swift]</a>
                <br>
                <span class="suffix-box-title">作者签名</span>：所有伟大的事情都源于梦想，始于微不足道.
                <br>
                <span class="suffix-box-title">关于主题</span>：<a href="https://github.com/first19326/Hexo-LiveForCode" target="_blank">Hexo - Live For Code</a>
                <br>
                <span class="suffix-box-title">版权声明</span>：文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" title="BY-NC-SA" target="_blank">BY-NC-SA</a> 许可协议，转载请注明出处
                <br>
            </div>
            <div style="clear: both;"></div>
        </div>
    </div>
    <div class="article-footer">
        
        
        <div class="article-prev-next">
            
                <a href="/2018/05/10/ReadSource/2018-05-10/" class="prev-prefix">« </a> 上一篇：    <a href="/2018/05/10/ReadSource/2018-05-10/" title="发布于 2018-05-10 12:00">Swift - 4 [Map.swift]</a>
                <br>
            
            
                <a href="/2018/01/25/ReadSource/2018-01-25/" class="next-prefix">» </a> 下一篇：    <a href="/2018/01/25/ReadSource/2018-01-25/" title="发布于 2018-01-25 12:00">Swift - 2 [Bool.swift]</a>
            
        </div>
    </div>
    
    <div class="article-comments">
        <div class="comments-title">
            评论列表
        </div>
        <div class="comments-content">
        </div>
    </div>

</div>

    </div>
</div>
    <div id="footer"></div>
    <div id="sidebar">
    <div class="menu-wrap" style="display:none;">
        <nav class="menu">
            <div class="menu-introduce"> 
                <div class="introduce-avatar"></div> 
                <div class="introduce-info"> 
                    <div class="introduce-user"><span></span></div>        
                </div> 
            </div> 
            <div class="menu-list">
                <ul></ul> 
            </div> 
            <div class="menu-link"></div> 
        </nav>
        <button class="menu-button-close"></button>
        <div class="morph-shape" id="morph-shape" data-morph-open="M-7.312,0H15c0,0,66,113.339,66,399.5C81,664.006,15,800,15,800H-7.312V0z;M-7.312,0H100c0,0,0,113.839,0,400c0,264.506,0,400,0,400H-7.312V0z">
            <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 100 800" preserveAspectRatio="none">
                <path d="M-7.312,0H0c0,0,0,113.839,0,400c0,264.506,0,400,0,400h-7.312V0z"/>
            </svg>
        </div>
    </div>
    <button class="menu-button-open">MENU</button>
    <div class="menu-cover"></div>
</div>
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/css/search.css">
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/js/iscroll.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/js/instantsearch.min.js"></script>
<div class="search-window">
    <div class="search-content">
        <div class="search-content-icon">
            <i class="iconfont icon-search"></i>
        </div>
        <div id="search-input" class="search-input"></div>
    </div>

    <div class="search-scroll">
        <div class="search-result">
            <div id="search-stats" class="search-stats"></div>
            <div id="search-hits"></div>
            <div id="search-pagination" class="search-pagination"></div>
        </div>
    </div>

    <span class="search-close-icon">
        <i class="iconfont icon-close"></i>
    </span>
</div>
    <div id="tools">
    <div class="progressbar-top"></div>
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/css/APlayer.css">
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/js/APlayer.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/js/Meting.min.js"></script>
    <meting-js id="3778678" lrcshow="false" server="netease" type="playlist" fixed="true" autoplay="false" loop="all" order="random" preload="auto" volume="0.67" mutex="true"></meting-js>
    <div class="wrap-right"></div>
    <div class="loading"></div>
</div>
    <script>
    window.config = {
        GitHubUserName     : 'kaikaka',
        GitHubRepositories : 'Hexo-LiveForCode',

        BlogUser      : '林江仙',
        BlogAvatar    : 'https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/image/sidebar/avatar.jpg',
        BlogStartDate : '2020-10-24',

        WebsiteTitleBlur         : 'Hi, 林江仙',
        WebsiteTitleBlurTimeOut  : 500,
        WebsiteTitleFocus        : '(*´∇｀*) 欢迎回来!',
        WebsiteTitleFocusTimeOut : 1000,
        WebsiteFavicon           : 'https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/image/website/logo.png',

        ProgressBar: {
            id       : 'topProgressBar',
            color    : '#77B6FF',
            height   : '2px',
            duration : 0.2
        },

        Loading: {
            rebound: {
                tension  : 16,
                friction : 5
            },
            spinner: {
                id     : 'spinner',
                radius : 90,
                sides  : 3,
                depth  : 4,
                colors : {
                    background : '#F0F0F0',
                    stroke     : '#272633',
                    base       : '',
                    child      : '#272633'
                },
                alwaysForward : true,
                restAt        : 0.5,
                renderBase    : false
            }
        },

        HomeHeaderAnimationRendered : true,
        HomeHeaderAnimation         : {
            radius      : 15,
            density     : 0.2,
            color       : 'rgba(255, 255, 255, .2)',
            clearOffset : 0.3
        },

        ArticleHeaderAnimationRendered : false,
        ArticleHeaderAnimation         : {
            triW                  : 14,
            triH                  : 20,
            neighbours            : [
                
                    'side',
                
                    'top',
                
                    'bottom',
                
            ],
            speedTrailAppear      : 0.1,
            speedTrailDisappear   : 0.1,
            speedTriOpen          : 1,
            trailMaxLength        : 30,
            trailIntervalCreation : 100,
            delayBeforeDisappear  : 2,
            colors                : [
                
                    '#96EDA6',
                
                    '#5BC6A9',
                
                    '#38668C',
                
                    '#374D84',
                
                    '#BED5CB',
                
                    '#62ADC6',
                
                    '#8EE5DE',
                
                    '#304E7B',
                
            ]
        },

        BackAnimationRendered          : true,
        IEBrowserBackAnimationRendered : false,
        BackAnimation                  : {
            colorSaturation  : '60%',
            colorBrightness  : '50%',
            colorAlpha       : 0.5,
            colorCycleSpeed  : 5,
            verticalPosition : 'random',
            horizontalSpeed  : 200,
            ribbonCount      : 3,
            strokeSize       : 0,
            parallaxAmount   : -0.2,
            animateSections  : true
        },

        HomeHeaderImage : [
            
                'https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/image/header/home.jpg',
            
                'https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/image/header/home.jpeg',
            
        ],
        HomeBannerText  : '',

        ArticleHeaderImage : [
            
                'https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/image/header/article.jpg',
            
        ],

        OtherBannerText  : '',

        MenuList : [
            
                {
                    name   : '首页',
                    href   : '/',    
                    target : '',
                    class  : ''
                },
            
                {
                    name   : '标签',
                    href   : '/tag',    
                    target : '',
                    class  : ''
                },
            
                {
                    name   : '分类',
                    href   : '/category',    
                    target : '',
                    class  : ''
                },
            
                {
                    name   : '归档',
                    href   : '/archive',    
                    target : '',
                    class  : ''
                },
            
                {
                    name   : '赞赏',
                    href   : '/donate',    
                    target : '',
                    class  : ''
                },
            
                {
                    name   : '关于',
                    href   : '/about',    
                    target : '',
                    class  : ''
                },
            
                {
                    name   : '订阅',
                    href   : '/atom.xml',    
                    target : '_blank',
                    class  : ''
                },
            
                {
                    name   : '搜索',
                    href   : '',    
                    target : '',
                    class  : 'search'
                },
            
                {
                    name   : '留言板',
                    href   : '/comment',    
                    target : '',
                    class  : ''
                },
            
                {
                    name   : '友情链接',
                    href   : '/friend',    
                    target : '',
                    class  : ''
                },
            
        ],
        MenuLink : [
            
                {
                    icon : 'icon-weibo', 
                    url  : ''
                },
            
                {
                    icon : 'icon-wechat', 
                    url  : ''
                },
            
                {
                    icon : 'icon-qq', 
                    url  : ''
                },
            
                {
                    icon : 'icon-github', 
                    url  : 'https://github.com/kaikaka'
                },
            
        ],

        FooterStyle : 2,
        BottomText  : {
            icon    : '',
            left    : '思维殿堂',
            right   : '所有伟大的事情都源于梦想,始于微不足道.'
        },
        ThemeInfo   : false,

        ConsoleList : [
            
                [
                    
                        'Based on cnblogs theme SimpleMemory.',
                    
                        '',
                    
                ],
            
                [
                    
                        'SimpleMemory Author:',
                    
                        'BNDong',
                    
                ],
            
                [
                    
                        'Theme:',
                    
                        'LiveForCode',
                    
                ],
            
        ],

        FontIconExtend : "",

        Donate : {
            paypal  : '',
            bitcoin : '',
            alipay  : 'https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/image/donate/alipay.png',
            wechat  : 'https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/image/donate/wechat.png'
        },

        Code : {
            style : 'normal'
        },  

        Search : {
            applicationID : '010C3EANT8',
            apiKey        : 'c7abab9f11b79102b9aff7fe6d41447d',
            indexName     : 'Notes',
            hits          : {
                page : 10
            },
            labels        : {
                placeholder : '搜索',
                empty       : '未发现与 「${query}」 相关的内容',
                stats       : '${hits} 条相关条目，使用了 ${time} 毫秒',
            }
        }, 

        Valine : {
            switch         : true,
            el             : '.comments-content',
            appId          : 'srhKtvWPQTWYKh3qX8G8M7v0-gzGzoHsz',
            appKey         : '8uVSP1q6UlALVC5igYfIfv2h',
            placeholder    : '你是我一生只会遇见一次的惊喜...',
            avatar         : 'mm',
            meta           : 'nick,mail,link',
            requiredFields : 'nick,mail',
            pageSize       : 5,
            lang           : 'zh-cn',
            visitor        : true,
            enableQQ       : true
        },

        Tocbot : {
            switch                : true,
            tocSelector           : '.toc',
            contentSelector       : '.article-body',
            headingSelector       : 'h1, h2, h3, h4, h5',
            headingsOffset        : 0,
            scrollSmooth          : true,
            scrollSmoothOffset    : -5,
            positionFixedSelector : '.toc',
            positionFixedClass    : 'toc-fixed',
            fixedSidebarOffset    : '',
        },

        Require : {
            baseUrl     : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/js/",
            waitSeconds : 100
        },

        Meting : {
            id       : "3778678", 
            lrcshow  : false, 
            server   : "netease", 
            type     : "playlist", 
            fixed    : true, 
            autoplay : false, 
            loop     : "all", 
            order    : "random", 
            preload  : "auto", 
            volume   : 0.67, 
            mutex    : true
        },

        LazyLoad : {
            default : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/image/website/lazyload.svg"
        },
  

        Style : {
            aplayer          : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/css/APlayer.css",
            archive          : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/css/archive.css",
            donate           : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/css/donate.css",
            fancybox         : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/css/jquery.fancybox.css",
            footer           : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/css/footer.css",
            iconfont         : "https://at.alicdn.com/t/font_1546312_l3yohatebw.css",
            index            : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/css/index.css",
            menuBubble       : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/css/menu-bubble.css",
            page             : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/css/page.css",
            post             : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/css/post.css",
            search           : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/css/search.css",
            tocbot           : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/css/tocbot.css",
            normal           : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/css/normal.css",
            night            : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/css/night.css",
            clipboard        : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/css/clipboard.css"
        },

        Script: {
            aplayer          : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/js/APlayer.min.js",
            config           : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/js/require.config.js",
            index            : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/js/index.js",
            instantSearch    : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/js/instantsearch.min.js",
            jQuery           : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/js/jquery-3.4.1.min.js",
            loading          : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/js/loading.js",
            meting           : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/js/Meting.min.js",
            iscroll          : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/js/iscroll.js",
            require          : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/js/require.min.js"
        },

        Font: {
            LongCang   : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/font/LongCang.css",
            Monda      : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/font/Monda.css",
            NotoSansSC : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/font/NotoSansSC.css",
            Playball   : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/font/Playball.css",
            PTMono     : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/font/PTMono.css",
            RobotoSlab : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/font/RobotoSlab.css",
            Rosario    : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/font/Rosario.css",
            UbuntuMono : "https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/font/UbuntuMono.css"
        },

        Suffix : {
            about : '所有伟大的事情都源于梦想，始于微不足道.'
        },
            
        Theme : {
            url  : 'https://github.com/first19326/Hexo-LiveForCode',
            name : 'Hexo - Live For Code'
        }  
    };
</script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/first19326/hexo-liveforcode@master/static/js/index.js"></script>
</body>
</html>
